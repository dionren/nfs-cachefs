// use std::env;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process;
use std::env;
use std::sync::Arc;

use clap::{Arg, Command};
use fuser::MountOption;
use tracing::{error, info, warn};
use tracing_subscriber;

use nfs_cachefs::core::config::Config;
use nfs_cachefs::fs::cachefs::CacheFs;

mod mount_helper;

/// Ê£ÄÊü•ÊòØÂê¶‰ª• mount helper Ê®°ÂºèËøêË°å
fn is_mount_helper_mode() -> bool {
    if let Some(program_name) = env::args().next() {
        program_name.ends_with("mount.cachefs") || 
        (env::args().count() >= 4 && env::args().any(|arg| arg == "-o"))
    } else {
        false
    }
}

/// Ëß£Êûê mount helper ÂèÇÊï∞
fn parse_mount_helper_args() -> Result<(Config, PathBuf, Vec<MountOption>), String> {
    let args: Vec<String> = env::args().collect();
    
    // mount.cachefs <source> <target> -o <options>
    if args.len() < 4 {
        return Err("Invalid mount helper arguments".to_string());
    }
    
    let _source = &args[1];  // ÂøΩÁï•sourceÔºåÊàë‰ª¨‰ΩøÁî®ÈÄâÈ°π‰∏≠ÁöÑnfs_backend
    let mountpoint = PathBuf::from(&args[2]);
    
    let mut mount_options = Vec::new();
    let mut config_options = HashMap::new();
    let mut should_daemonize = true;  // ÈªòËÆ§ÂêéÂè∞ËøêË°å
    
    // Âº∫Âà∂Âè™ËØªÊ®°Âºè
    mount_options.push(MountOption::RO);
    
    // Ëß£Êûê -o ÈÄâÈ°π
    let mut i = 3;
    while i < args.len() {
        if args[i] == "-o" && i + 1 < args.len() {
            let options_str = &args[i + 1];
            for option in options_str.split(',') {
                let option = option.trim();
                if option.is_empty() {
                    continue;
                }
                
                // Ëß£Êûê key=value Ê†ºÂºèÁöÑÈÄâÈ°π
                if let Some((key, value)) = option.split_once('=') {
                    config_options.insert(key.to_string(), value.to_string());
                } else {
                    // Â§ÑÁêÜÊ†áÂøóÈÄâÈ°π
                    match option {
                        "ro" => {
                            // Â∑≤ÁªèÈªòËÆ§ËÆæÁΩÆ‰∏∫Âè™ËØªÔºåÂøΩÁï•
                        }
                        "rw" => {
                            warn!("Read-write mode is not supported, filesystem will be mounted read-only");
                            // ‰∏çÊ∑ªÂä† RW ÈÄâÈ°πÔºå‰øùÊåÅÂè™ËØª
                        }
                        "allow_other" => {
                            mount_options.push(MountOption::AllowOther);
                        }
                        "allow_root" => {
                            mount_options.push(MountOption::AllowRoot);
                        }
                        "auto_unmount" => {
                            mount_options.push(MountOption::AutoUnmount);
                        }
                        "foreground" | "fg" => {
                            should_daemonize = false;
                        }
                        _ => {
                            // Êú™Áü•ÈÄâÈ°πÔºå‰Ωú‰∏∫Ëá™ÂÆö‰πâÈÄâÈ°πÂ§ÑÁêÜ
                            mount_options.push(MountOption::CUSTOM(option.to_string()));
                        }
                    }
                }
            }
            break;
        }
        i += 1;
    }
    
    // Â¶ÇÊûúÈúÄË¶ÅÂêéÂè∞ËøêË°åÔºåÊ∑ªÂä†Âà∞ÈÖçÁΩÆ‰∏≠
    if should_daemonize {
        config_options.insert("_daemonize".to_string(), "true".to_string());
    }
    
    // ‰ªéÈÖçÁΩÆÈÄâÈ°πÂàõÂª∫Config
    let nfs_backend = config_options.get("nfs_backend")
        .ok_or("Missing required option: nfs_backend")?;
    let nfs_backend_path = PathBuf::from(nfs_backend);
    
    let cache_dir = config_options.get("cache_dir")
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("/tmp/nfs-cachefs"));
    
    let cache_size_gb = config_options.get("cache_size_gb")
        .and_then(|s| s.parse().ok())
        .unwrap_or(10);
    
    let block_size_mb = config_options.get("block_size_mb")
        .and_then(|s| s.parse().ok())
        .unwrap_or(64);
    
    let max_concurrent_caching = config_options.get("max_concurrent")
        .and_then(|s| s.parse().ok())
        .unwrap_or(10);
    
    let min_cache_file_size_mb = config_options.get("min_cache_file_size_mb")
        .and_then(|s| s.parse().ok())
        .unwrap_or(100);
    
    // üìä FUSEÊÄßËÉΩ‰ºòÂåñÂèÇÊï∞ - mount helperÊ®°Âºè
    let max_read_mb = block_size_mb.min(16); // Èôç‰ΩéÂà∞16MB‰ª•ÊèêÈ´òÂÖºÂÆπÊÄß
    
    // Ê∑ªÂä†ÂÖºÂÆπÁöÑFUSEÊÄßËÉΩ‰ºòÂåñÊåÇËΩΩÈÄâÈ°π
    mount_options.push(MountOption::CUSTOM(format!("max_read={}", max_read_mb * 1024 * 1024)));
    // Ê≥®ÊÑèÔºöÊüê‰∫õFUSEÈÄâÈ°πÂèØËÉΩ‰∏çË¢´ÊâÄÊúâÁâàÊú¨ÊîØÊåÅÔºåÂè™Ê∑ªÂä†ÂÖºÂÆπÁöÑÈÄâÈ°π
    
    // ËÆæÁΩÆÈ¢ÑËØªÂ§ßÂ∞è‰ª•ÂåπÈÖçÂùóÂ§ßÂ∞è
    let readahead_bytes = max_read_mb * 2 * 1024 * 1024; // È¢ÑËØª‰∏∫max_readÁöÑ2ÂÄç
    
    let config = Config {
        nfs_backend_path,
        cache_dir,
        mount_point: mountpoint.clone(),
        max_cache_size_bytes: cache_size_gb * 1024 * 1024 * 1024,
        cache_block_size: block_size_mb * 1024 * 1024,
        max_concurrent_caching,
        enable_checksums: true,
        cache_ttl_seconds: None,
        eviction_policy: nfs_cachefs::core::config::EvictionPolicy::Lru,
        direct_io: true,
        readahead_bytes: readahead_bytes,  // ‰ΩøÁî®ËÆ°ÁÆóÁöÑÈ¢ÑËØªÂ§ßÂ∞è
        min_cache_file_size: min_cache_file_size_mb * 1024 * 1024,
        allow_async_read: false, // ‰ΩøÁî®ÂêåÊ≠•Áõ¥ËØªËé∑ÂæóÊõ¥Â•ΩÁöÑÊÄßËÉΩ
        smart_cache: nfs_cachefs::core::config::SmartCacheConfig::default(),
        nvme: nfs_cachefs::core::config::NvmeConfig::default(),
    };
    
    Ok((config, mountpoint, mount_options))
}

/// Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
fn parse_args() -> (Config, PathBuf, Vec<MountOption>) {
    // Ê£ÄÊü•ÊòØÂê¶‰ª•mount helperÊ®°ÂºèËøêË°å
    if is_mount_helper_mode() {
        match parse_mount_helper_args() {
            Ok(result) => return result,
            Err(e) => {
                error!("Mount helper mode error: {}", e);
                process::exit(1);
            }
        }
    }
    
    // ÂéüÊúâÁöÑÂëΩ‰ª§Ë°åÂèÇÊï∞Ëß£ÊûêÈÄªËæë
    let matches = Command::new("nfs-cachefs")
        .version("0.6.0")
        .author("NFS-CacheFS Team")
        .about("High-performance read-only asynchronous caching filesystem for NFS")
        .arg(
            Arg::new("nfs_backend")
                .help("NFS backend directory path")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::new("mountpoint")
                .help("Mount point directory")
                .required(true)
                .index(2),
        )
        .arg(
            Arg::new("options")
                .short('o')
                .long("options")
                .help("Mount options (comma-separated)")
                .value_name("OPTIONS")
                .action(clap::ArgAction::Set),
        )
        .arg(
            Arg::new("cache_dir")
                .long("cache-dir")
                .help("Cache directory path")
                .value_name("PATH")
                .action(clap::ArgAction::Set),
        )
        .arg(
            Arg::new("cache_size")
                .long("cache-size")
                .help("Cache size in GB")
                .value_name("SIZE")
                .action(clap::ArgAction::Set),
        )
        .arg(
            Arg::new("block_size")
                .long("block-size")
                .help("Block size in MB")
                .value_name("SIZE")
                .action(clap::ArgAction::Set),
        )
        .arg(
            Arg::new("max_concurrent_tasks")
                .long("max-concurrent-tasks")
                .help("Maximum concurrent caching tasks")
                .value_name("COUNT")
                .action(clap::ArgAction::Set),
        )
        .arg(
            Arg::new("foreground")
                .short('f')
                .long("foreground")
                .help("Run in foreground")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("debug")
                .short('d')
                .long("debug")
                .help("Enable debug logging")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("min_cache_file_size")
                .long("min-cache-file-size")
                .help("Minimum file size to cache in MB (default: 100)")
                .value_name("SIZE_MB")
                .action(clap::ArgAction::Set),
        )
        .get_matches();

    let nfs_backend = PathBuf::from(matches.get_one::<String>("nfs_backend").unwrap());
    let mountpoint = PathBuf::from(matches.get_one::<String>("mountpoint").unwrap());
    
    // Ëß£ÊûêÊåÇËΩΩÈÄâÈ°π
    let mut mount_options = Vec::new();
    let mut config_options = HashMap::new();
    
    // Âº∫Âà∂Âè™ËØªÊ®°Âºè
    mount_options.push(MountOption::RO);
    
    if let Some(options_str) = matches.get_one::<String>("options") {
        for option in options_str.split(',') {
            let option = option.trim();
            if option.is_empty() {
                continue;
            }
            
            // Ëß£Êûê key=value Ê†ºÂºèÁöÑÈÄâÈ°π
            if let Some((key, value)) = option.split_once('=') {
                config_options.insert(key.to_string(), value.to_string());
            } else {
                // Â§ÑÁêÜÊ†áÂøóÈÄâÈ°π
                match option {
                    "ro" => {
                        // Â∑≤ÁªèÈªòËÆ§ËÆæÁΩÆ‰∏∫Âè™ËØªÔºåÂøΩÁï•
                    }
                    "rw" => {
                        warn!("Read-write mode is not supported, filesystem will be mounted read-only");
                        // ‰∏çÊ∑ªÂä† RW ÈÄâÈ°πÔºå‰øùÊåÅÂè™ËØª
                    }
                    "allow_other" => mount_options.push(MountOption::AllowOther),
                    "allow_root" => mount_options.push(MountOption::AllowRoot),
                    "auto_unmount" => mount_options.push(MountOption::AutoUnmount),
                    "foreground" | "fg" => {
                        // foreground ÈÄâÈ°π‰∏çÂ∫îËØ•‰º†ÈÄíÁªô FUSEÔºåÁî±Á®ãÂ∫èËá™Â∑±Â§ÑÁêÜ
                        // ËøôÈáå‰∏çÂÅö‰ªª‰ΩïÊìç‰ΩúÔºåÂõ†‰∏∫ÂâçÂè∞ËøêË°åÈÄªËæëÂ∑≤ÁªèÂú® main ÂáΩÊï∞‰∏≠Â§ÑÁêÜ‰∫Ü
                    },
                    _ => {
                        // Êú™Áü•ÈÄâÈ°πÔºå‰Ωú‰∏∫Ëá™ÂÆö‰πâÈÄâÈ°πÂ§ÑÁêÜ
                        mount_options.push(MountOption::CUSTOM(option.to_string()));
                    }
                }
            }
        }
    }
    
    // ‰ªéÂëΩ‰ª§Ë°åÂèÇÊï∞ÂàõÂª∫ÈÖçÁΩÆÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
    let cache_dir = matches
        .get_one::<String>("cache_dir")
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("/tmp/nfs-cachefs"));
    
    let cache_size_gb = matches
        .get_one::<String>("cache_size")
        .and_then(|s| s.parse().ok())
        .unwrap_or(10);
    
    let block_size_mb = matches
        .get_one::<String>("block_size")
        .and_then(|s| s.parse().ok())
        .unwrap_or(64);
    
    let max_concurrent_caching = matches
        .get_one::<String>("max_concurrent_tasks")
        .and_then(|s| s.parse().ok())
        .unwrap_or(10);
    
    let min_cache_file_size_mb = matches
        .get_one::<String>("min_cache_file_size")
        .and_then(|s| s.parse().ok())
        .unwrap_or(100);
    
    // üìä FUSEÊÄßËÉΩ‰ºòÂåñÂèÇÊï∞
    let max_read_mb = block_size_mb.min(16); // Èôç‰ΩéÂà∞16MB‰ª•ÊèêÈ´òÂÖºÂÆπÊÄß
    
    // Ê∑ªÂä†ÂÖºÂÆπÁöÑFUSEÊÄßËÉΩ‰ºòÂåñÊåÇËΩΩÈÄâÈ°π
    mount_options.push(MountOption::CUSTOM(format!("max_read={}", max_read_mb * 1024 * 1024)));
    // Ê≥®ÊÑèÔºöÊüê‰∫õFUSEÈÄâÈ°πÂèØËÉΩ‰∏çË¢´ÊâÄÊúâÁâàÊú¨ÊîØÊåÅÔºåÂè™Ê∑ªÂä†ÂÖºÂÆπÁöÑÈÄâÈ°π
    
    // ËÆæÁΩÆÈ¢ÑËØªÂ§ßÂ∞è‰ª•ÂåπÈÖçÂùóÂ§ßÂ∞è
    let readahead_bytes = max_read_mb * 2 * 1024 * 1024; // È¢ÑËØª‰∏∫max_readÁöÑ2ÂÄç
    
    let config = Config {
        nfs_backend_path: nfs_backend.clone(),
        cache_dir,
        mount_point: mountpoint.clone(),
        max_cache_size_bytes: cache_size_gb * 1024 * 1024 * 1024,
        cache_block_size: block_size_mb * 1024 * 1024,
        max_concurrent_caching,
        enable_checksums: true,
        cache_ttl_seconds: None,
        eviction_policy: nfs_cachefs::core::config::EvictionPolicy::Lru,
        direct_io: true,
        readahead_bytes: readahead_bytes,  // ‰ΩøÁî®ËÆ°ÁÆóÁöÑÈ¢ÑËØªÂ§ßÂ∞è
        min_cache_file_size: min_cache_file_size_mb * 1024 * 1024,
        allow_async_read: false, // ‰ΩøÁî®ÂêåÊ≠•Áõ¥ËØªËé∑ÂæóÊõ¥Â•ΩÁöÑÊÄßËÉΩ
        smart_cache: nfs_cachefs::core::config::SmartCacheConfig::default(),
        nvme: nfs_cachefs::core::config::NvmeConfig::default(),
    };
    
    // ‰∏çË¶ÅÂ∞Ü foreground ‰º†ÈÄíÁªô FUSEÔºåÁ®ãÂ∫è‰ºöËá™Â∑±Â§ÑÁêÜÂâçÂè∞ËøêË°å
    // if matches.get_flag("foreground") {
    //     mount_options.push(MountOption::CUSTOM("foreground".to_string()));
    // }
    
    (config, mountpoint, mount_options)
}

/// ÂàùÂßãÂåñÊó•ÂøóÁ≥ªÁªü
fn init_logging(log_level: &str) {
    let level = match log_level.to_lowercase().as_str() {
        "trace" => tracing::Level::TRACE,
        "debug" => tracing::Level::DEBUG,
        "info" => tracing::Level::INFO,
        "warn" => tracing::Level::WARN,
        "error" => tracing::Level::ERROR,
        _ => tracing::Level::INFO,
    };
    
    // ÂàõÂª∫Ëá™ÂÆö‰πâÁöÑÊó•ÂøóÊ†ºÂºèÔºåÁ™ÅÂá∫ÊòæÁ§∫ÁºìÂ≠òÂíåÊÄßËÉΩÁõ∏ÂÖ≥ÁöÑÊó•Âøó
    tracing_subscriber::fmt()
        .with_max_level(level)
        .with_target(false)
        .with_thread_ids(false)  // ÂÖ≥Èó≠Á∫øÁ®ãID‰ª•ÂáèÂ∞ëÂπ≤Êâ∞
        .with_line_number(false)  // ÂÖ≥Èó≠Ë°åÂè∑‰ª•‰øùÊåÅÊó•ÂøóÁÆÄÊ¥Å
        .with_level(true)
        .with_ansi(true)  // ÂêØÁî®ÂΩ©Ëâ≤ËæìÂá∫
        .compact()  // ‰ΩøÁî®Á¥ßÂáëÊ†ºÂºè
        .init();
}

/// ÂàùÂßãÂåñËØ¶ÁªÜÊó•ÂøóÁ≥ªÁªüÔºàÁî®‰∫éË∞ÉËØïÂíåÊÄßËÉΩÂàÜÊûêÔºâ
fn init_verbose_logging() {
    // ‰∏∫ÁºìÂ≠òÂíåÊÄßËÉΩÂàÜÊûêÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    std::env::set_var("RUST_LOG", "nfs_cachefs=info,warn");
    
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .with_target(false)
        .with_thread_ids(false)
        .with_line_number(false)
        .with_level(true)
        .with_ansi(true)
        .compact()
        .init();
        
    // ÊâìÂç∞ÊÄßËÉΩÁõëÊéßÊèêÁ§∫
    tracing::info!("üîç PERFORMANCE MONITORING ENABLED");
    tracing::info!("üìä Cache operations will be logged with detailed timing");
    tracing::info!("üöÄ Look for emoji indicators: üìÅ=read, üöÄ=cache hit, ‚ùå=cache miss, üîÑ=caching, ‚úÖ=success");
}

/// È™åËØÅÈÖçÁΩÆ
fn validate_config(config: &Config) -> Result<(), String> {
    // Ê£ÄÊü• NFS ÂêéÁ´ØÁõÆÂΩïÊòØÂê¶Â≠òÂú®
    if !config.nfs_backend_path.exists() {
        return Err(format!("NFS backend directory does not exist: {}", config.nfs_backend_path.display()));
    }
    
    if !config.nfs_backend_path.is_dir() {
        return Err(format!("NFS backend path is not a directory: {}", config.nfs_backend_path.display()));
    }
    
    // Ê£ÄÊü•ÁºìÂ≠òÁõÆÂΩï
    if let Some(parent) = config.cache_dir.parent() {
        if !parent.exists() {
            return Err(format!("Cache directory parent does not exist: {}", parent.display()));
        }
    }
    
    // ÂàõÂª∫ÁºìÂ≠òÁõÆÂΩïÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
    if !config.cache_dir.exists() {
        std::fs::create_dir_all(&config.cache_dir)
            .map_err(|e| format!("Failed to create cache directory: {}", e))?;
    }
    
    // Ê£ÄÊü•ÁºìÂ≠òÂ§ßÂ∞è
    if config.max_cache_size_bytes == 0 {
        return Err("Cache size must be greater than 0".to_string());
    }
    
    if config.max_cache_size_bytes > 1000 * 1024 * 1024 * 1024 {
        warn!("Cache size is very large ({}GB), make sure you have enough disk space", config.max_cache_size_bytes / (1024 * 1024 * 1024));
    }
    
    // Ê£ÄÊü•ÂùóÂ§ßÂ∞è
    if config.cache_block_size == 0 || config.cache_block_size > 1024 * 1024 * 1024 {
        return Err("Block size must be between 1 and 1024 MB".to_string());
    }
    
    // Ê£ÄÊü•Âπ∂Âèë‰ªªÂä°Êï∞
    if config.max_concurrent_caching == 0 {
        return Err("Max concurrent tasks must be greater than 0".to_string());
    }
    
    if config.max_concurrent_caching > 100 {
        warn!("Very high concurrent tasks count ({}), this may impact performance", config.max_concurrent_caching);
    }
    
    Ok(())
}

/// Ê£ÄÊü•ÊåÇËΩΩÁÇπ
fn validate_mountpoint(mountpoint: &PathBuf) -> Result<(), String> {
    if !mountpoint.exists() {
        return Err(format!("Mount point does not exist: {}", mountpoint.display()));
    }
    
    if !mountpoint.is_dir() {
        return Err(format!("Mount point is not a directory: {}", mountpoint.display()));
    }
    
    // Ê£ÄÊü•ÊåÇËΩΩÁÇπÊòØÂê¶‰∏∫Á©∫
    match std::fs::read_dir(mountpoint) {
        Ok(mut entries) => {
            if entries.next().is_some() {
                warn!("Mount point is not empty: {}", mountpoint.display());
            }
        }
        Err(e) => {
            return Err(format!("Cannot read mount point directory: {}", e));
        }
    }
    
    Ok(())
}

/// ‰∏ªÂáΩÊï∞
#[tokio::main]
async fn main() {
    // ÂÖàËß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞‰ª•Á°ÆÂÆöÊòØÂê¶ÈúÄË¶ÅÂâçÂè∞ËøêË°å
    let args: Vec<String> = std::env::args().collect();
    let is_foreground = args.iter().any(|arg| arg == "--foreground" || arg == "-f") || 
                       args.iter().any(|arg| arg.contains("foreground"));
    
    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂêéÂè∞ËøêË°åÔºàÂú®Ëß£ÊûêÂèÇÊï∞‰πãÂâçÔºâ
    if mount_helper::should_daemonize(&args) && !is_foreground {
        // Âú®Êó•ÂøóÂàùÂßãÂåñ‰πãÂâçËøõË°åÂÆàÊä§ËøõÁ®ãÂåñ
        if let Err(e) = mount_helper::daemonize() {
            eprintln!("Failed to daemonize: {}", e);
            process::exit(1);
        }
    }
    
    // Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
    let (config, mountpoint, mount_options) = parse_args();
    
    // ÂàùÂßãÂåñËØ¶ÁªÜÊó•ÂøóÁ≥ªÁªü‰ª•‰æøËßÇÂØüÁºìÂ≠òÊÄßËÉΩ
    init_verbose_logging();
    
    info!("üöÄ Starting NFS-CacheFS v0.6.0 (READ-ONLY MODE)");
    info!("üìÅ NFS Backend: {}", config.nfs_backend_path.display());
    info!("üíæ Cache Directory: {}", config.cache_dir.display());
    info!("üìç Mount Point: {}", mountpoint.display());
    info!("üíø Cache Size: {}GB", config.max_cache_size_bytes / (1024 * 1024 * 1024));
    info!("üì¶ Block Size: {}MB", config.cache_block_size / (1024 * 1024));
    info!("üîÑ Readahead Size: {}MB", config.readahead_bytes / (1024 * 1024));
    info!("‚ö° Max Concurrent Tasks: {}", config.max_concurrent_caching);
    info!("üîí Filesystem Mode: READ-ONLY");
    info!("üöÄ Performance Optimization: ENABLED (4MB blocks + zero-copy reads)");
    info!("üìä FUSE Optimizations: max_read={} ({}MB)", config.cache_block_size.min(16 * 1024 * 1024), config.cache_block_size.min(16 * 1024 * 1024) / (1024 * 1024));
    info!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    info!("üéØ Ready for high-performance caching with large block I/O!");
    info!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    
    // È™åËØÅÈÖçÁΩÆ
    if let Err(e) = validate_config(&config) {
        error!("Configuration validation failed: {}", e);
        process::exit(1);
    }
    
    // È™åËØÅÊåÇËΩΩÁÇπ
    if let Err(e) = validate_mountpoint(&mountpoint) {
        error!("Mount point validation failed: {}", e);
        process::exit(1);
    }
    
    // ÂàõÂª∫Êñá‰ª∂Á≥ªÁªüÂÆû‰æã
    let fs = match CacheFs::new(config.clone()) {
        Ok(fs) => fs,
        Err(e) => {
            error!("Failed to create filesystem: {}", e);
            process::exit(1);
        }
    };
    
    info!("Read-only filesystem created successfully");
    
    // ËÆæÁΩÆ‰ø°Âè∑Â§ÑÁêÜ
    let (tx, mut rx) = tokio::sync::mpsc::channel(1);
    let fs_for_signal = Arc::new(fs);
    let fs_for_mount = Arc::clone(&fs_for_signal);
    
    // Â§ÑÁêÜ SIGINT Âíå SIGTERM
    tokio::spawn(async move {
        let mut sigint = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::interrupt()).unwrap();
        let mut sigterm = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate()).unwrap();
        
        tokio::select! {
            _ = sigint.recv() => {
                info!("Received SIGINT, shutting down...");
                // ‰ºòÈõÖÂÖ≥Èó≠Êñá‰ª∂Á≥ªÁªüÁªÑ‰ª∂
                let _ = fs_for_signal.shutdown().await;
                let _ = tx.send(()).await;
            }
            _ = sigterm.recv() => {
                info!("Received SIGTERM, shutting down...");
                // ‰ºòÈõÖÂÖ≥Èó≠Êñá‰ª∂Á≥ªÁªüÁªÑ‰ª∂
                let _ = fs_for_signal.shutdown().await;
                let _ = tx.send(()).await;
            }
        }
    });
    
    // ÊåÇËΩΩÊñá‰ª∂Á≥ªÁªü
    info!("Mounting filesystem...");
    
    // ÂÖãÈöÜmountpoint‰ª•ÈÅøÂÖçÊâÄÊúâÊùÉÈóÆÈ¢ò
    let mountpoint_for_task = mountpoint.clone();
    
    // ÂêØÂä®ÊåÇËΩΩ‰ªªÂä°
    let mut mount_result = tokio::task::spawn_blocking(move || {
        // ‰∏ÄÊó¶Ë∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞ÔºåÊåÇËΩΩÂ∞±‰ºöÊàêÂäüÔºåÂπ∂‰∏îÂáΩÊï∞‰ºö‰∏ÄÁõ¥ËøêË°åÁõ¥Âà∞Âç∏ËΩΩ
        // Ê≥®ÊÑèÔºöËøôÈáåÈúÄË¶ÅËß£ÂºïÁî®ArcÊù•Ëé∑ÂèñCacheFsÂÆû‰æã
        let fs_ref = Arc::try_unwrap(fs_for_mount).unwrap_or_else(|arc| (*arc).clone());
        fuser::mount2(fs_ref, &mountpoint_for_task, &mount_options)
    });
    
    // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥ËÆ©ÊåÇËΩΩÂÆåÊàê
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    // ÈÄöËøáÊ£ÄÊü• /proc/mounts Êù•È™åËØÅÊåÇËΩΩÊòØÂê¶ÊàêÂäü
    let mountpoint_str = mountpoint.to_string_lossy();
    let mount_check = tokio::process::Command::new("grep")
        .arg(&*mountpoint_str)
        .arg("/proc/mounts")
        .output()
        .await;
    
    match mount_check {
        Ok(output) if output.status.success() => {
            info!("‚úÖ Filesystem mounted successfully at {}", mountpoint_str);
            info!("üöÄ NFS-CacheFS is now running and ready to serve files");
            info!("üìä Performance monitoring is active - you'll see detailed cache logs");
            info!("üí° TIP: Run 'ls -la {}' to test file access", mountpoint_str);
        }
        _ => {
            // Â¶ÇÊûúÊ£ÄÊü•Â§±Ë¥•ÔºåÂèØËÉΩËøòÂú®ÊåÇËΩΩ‰∏≠ÔºåÁ≠âÂæÖÊõ¥ÈïøÊó∂Èó¥
            tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;
            info!("üìÅ Filesystem mounting initiated at {}", mountpoint_str);
            info!("üîÑ NFS-CacheFS is now running (mount verification may take a moment)");
            info!("üìä Performance monitoring is active - you'll see detailed cache logs");
        }
    }
    
    // Á≠âÂæÖÊåÇËΩΩ‰ªªÂä°ÂÆåÊàêÊàñ‰ø°Âè∑
    tokio::select! {
        result = &mut mount_result => {
            match result {
                Ok(Ok(())) => {
                    info!("Filesystem unmounted cleanly");
                }
                Ok(Err(e)) => {
                    error!("Filesystem error: {}", e);
                    process::exit(1);
                }
                Err(e) => {
                    error!("Mount task panicked: {}", e);
                    process::exit(1);
                }
            }
        }
        _ = rx.recv() => {
            info!("Received shutdown signal, unmounting...");
            // ‰∏ªÂä®Âç∏ËΩΩÊñá‰ª∂Á≥ªÁªü
            let _ = unmount_filesystem(&mountpoint).await;
            // Á≠âÂæÖÊåÇËΩΩ‰ªªÂä°ÂÆåÊàê
            match mount_result.await {
                Ok(Ok(())) => {
                    info!("Filesystem unmounted cleanly");
                }
                Ok(Err(e)) => {
                    warn!("Filesystem unmount error: {}", e);
                }
                Err(e) => {
                    warn!("Mount task error during shutdown: {}", e);
                }
            }
        }
    }
    
    info!("NFS-CacheFS shutdown complete");
}

/// ÂºÇÊ≠•Âç∏ËΩΩÊñá‰ª∂Á≥ªÁªü
async fn unmount_filesystem(mountpoint: &std::path::PathBuf) -> Result<(), String> {
    let mountpoint_str = mountpoint.to_string_lossy();
    
    // È¶ñÂÖàÂ∞ùËØïÊ≠£Â∏∏Âç∏ËΩΩ
    let result = tokio::process::Command::new("fusermount")
        .arg("-u")
        .arg(&*mountpoint_str)
        .output()
        .await;
    
    match result {
        Ok(output) if output.status.success() => {
            info!("Successfully unmounted filesystem at {}", mountpoint_str);
            return Ok(());
        }
        Ok(output) => {
            warn!("fusermount failed: {}", String::from_utf8_lossy(&output.stderr));
        }
        Err(e) => {
            warn!("Failed to run fusermount: {}", e);
        }
    }
    
    // Â¶ÇÊûúfusermountÂ§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®umount
    let result = tokio::process::Command::new("umount")
        .arg(&*mountpoint_str)
        .output()
        .await;
    
    match result {
        Ok(output) if output.status.success() => {
            info!("Successfully unmounted filesystem at {} using umount", mountpoint_str);
            Ok(())
        }
        Ok(output) => {
            let error_msg = format!("umount failed: {}", String::from_utf8_lossy(&output.stderr));
            warn!("{}", error_msg);
            Err(error_msg)
        }
        Err(e) => {
            let error_msg = format!("Failed to run umount: {}", e);
            warn!("{}", error_msg);
            Err(error_msg)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;
    
    #[test]
    fn test_config_validation() {
        let temp_dir = TempDir::new().unwrap();
        let nfs_backend = temp_dir.path().join("nfs");
        let cache_dir = temp_dir.path().join("cache");
        
        // ÂàõÂª∫ NFS ÂêéÁ´ØÁõÆÂΩï
        fs::create_dir(&nfs_backend).unwrap();
        
        let config = Config {
            nfs_backend_path: nfs_backend.clone(),
            cache_dir: cache_dir.clone(),
            mount_point: temp_dir.path().join("mount"),
            max_cache_size_bytes: 10 * 1024 * 1024 * 1024,
            cache_block_size: 64 * 1024 * 1024,
            max_concurrent_caching: 10,
            enable_checksums: true,
            cache_ttl_seconds: None,
            eviction_policy: nfs_cachefs::core::config::EvictionPolicy::Lru,
            direct_io: true,
            readahead_bytes: 1024 * 1024,
            min_cache_file_size: 100 * 1024 * 1024,
            allow_async_read: false,
            smart_cache: nfs_cachefs::core::config::SmartCacheConfig::default(),
        };
        
        // È™åËØÅÂ∫îËØ•ÊàêÂäü
        assert!(validate_config(&config).is_ok());
        
        // È™åËØÅÁºìÂ≠òÁõÆÂΩïÊòØÂê¶Ë¢´ÂàõÂª∫
        assert!(cache_dir.exists());
        
        // ÊµãËØïÊó†ÊïàÈÖçÁΩÆ
        let invalid_config = Config {
            nfs_backend_path: temp_dir.path().join("nonexistent"),
            cache_dir: cache_dir.clone(),
            mount_point: temp_dir.path().join("mount"),
            max_cache_size_bytes: 0,
            cache_block_size: 64 * 1024 * 1024,
            max_concurrent_caching: 10,
            enable_checksums: true,
            cache_ttl_seconds: None,
            eviction_policy: nfs_cachefs::core::config::EvictionPolicy::Lru,
            direct_io: true,
            readahead_bytes: 1024 * 1024,
            min_cache_file_size: 100 * 1024 * 1024,
            allow_async_read: false,
            smart_cache: nfs_cachefs::core::config::SmartCacheConfig::default(),
        };
        
        assert!(validate_config(&invalid_config).is_err());
    }
    
    #[test]
    fn test_mountpoint_validation() {
        let temp_dir = TempDir::new().unwrap();
        let mountpoint = temp_dir.path().to_path_buf();
        
        // Á©∫ÁõÆÂΩïÂ∫îËØ•ÈÄöËøáÈ™åËØÅ
        assert!(validate_mountpoint(&mountpoint).is_ok());
        
        // ‰∏çÂ≠òÂú®ÁöÑÁõÆÂΩïÂ∫îËØ•Â§±Ë¥•
        let nonexistent = temp_dir.path().join("nonexistent");
        assert!(validate_mountpoint(&nonexistent).is_err());
        
        // Êñá‰ª∂ËÄå‰∏çÊòØÁõÆÂΩïÂ∫îËØ•Â§±Ë¥•
        let file_path = temp_dir.path().join("file.txt");
        fs::write(&file_path, "test").unwrap();
        assert!(validate_mountpoint(&file_path).is_err());
    }
}
